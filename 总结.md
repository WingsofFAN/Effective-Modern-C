# 模板型别推导
* 在模板型别推导过程中，具有引用型别的实参会被当成非引用型别来处理换言之，其引用性会被忽略
* 对万能引用形参进行推导时，左值实参会进行特殊处理
* 对按值传递的形参进行推导时，若实参型别中带有 const volatile 饰词，则它们还是会被当作不带 const volatile 饰词的型别来处理
* 在模板型别推导过程中，数组或函数型别的实参会退化成对应的指针，除非它们被用来初始化引用

# auto型别推导
* 在一般情况下 auto 型别推导和模板型别推导是一模一样的，但是 auto 型别推导会假定用大括号括起的初始化表达式代表一个 std:: initializer_list, 但模板型别推导却不会
* 在函数返回值或 lambda 式的形参中使用 auto 意思是使用模板型别 推导而非auto 型别推导

# decltype
* 绝大多数情况下， decltype 会得出变量或表达式的型别而不作任何修改。
* 对于型别为T的左值表达式，除非该表达式仅有一个名字， decltype 总是得出型别 T&
* C++l4 支持 decltype(auto) ，和 auto 一样，它会从其初始化表达式出发来推导型别，但是它的型别推导使用的是 decltype 的规则

# 掌握查看型别推导结果的方法
* 利用IDE编辑器、编译器错误消息和 Boost.Typelndex 库常常能够查看到推导而得的型别
* 有些工具产生的结果可能会无用或者不准确，所以理解C+＋型别推导规则是必要的

# 优先选用 auto, 而非显式型别声
* auto 变量必须初始化，基本上对会导致兼容性和效率问题的型别不匹配现象免疫，还可以简化重构流程，通常也比显式指定型别要少打一些字。
* auto 型别的变量都有着条款2 和条款6 中所描述的毛病

# auto 推导的型别不符合要求时，使用带显式型别的初始化物习惯用法
* “隐形”的代理型别 可以导致 auto 祁据初始化表达式推导出 “错误的＂型别
* 带显式型别的初始化物习惯用法强制 auto 推导出你想要的型别。

# 在创建对象时注意区分 和｛｝
* 大括号初始化可以应用的语境最为宽泛，可以阻止隐式窄化型别转换，还对最令人苦恼之解析语法免疫
* 在构造函数重载决议期间，只要有任何可能，大括号初始化物就会与带有std::initializer_list型别的形参相匹配，即使其他重载版本有着貌似更加匹配的形参表
* 使用小括号还是大括号，会造成结果大相径庭的一个例子是：使用两个实参来创建一个 std::vector<数值型别＞对象
* 在模板内容进行对象创这时，到底应该使用小括号还是大括号会成为一个棘手问题。

# 条款 ：优先选用 nullptr, 而非 NULL
* 相对于NULL, 优先选用nullptr 
* 避免在整型和指针型别之间重载