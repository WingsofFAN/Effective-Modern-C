# 模板型别推导
* 在模板型别推导过程中，具有引用型别的实参会被当成非引用型别来处理换言之，其引用性会被忽略
* 对万能引用形参进行推导时，左值实参会进行特殊处理
* 对按值传递的形参进行推导时，若实参型别中带有 const volatile 饰词，则它们还是会被当作不带 const volatile 饰词的型别来处理
* 在模板型别推导过程中，数组或函数型别的实参会退化成对应的指针，除非它们被用来初始化引用

# auto型别推导
* 在一般情况下 auto 型别推导和模板型别推导是一模一样的，但是 auto 型别推导会假定用大括号括起的初始化表达式代表一个 std:: initializer_list, 但模板型别推导却不会
* 在函数返回值或 lambda 式的形参中使用 auto 意思是使用模板型别 推导而非auto 型别推导

# decltype
* 绝大多数情况下， decltype 会得出变量或表达式的型别而不作任何修改。
* 对于型别为T的左值表达式，除非该表达式仅有一个名字， decltype 总是得出型别 T&
* C++l4 支持 decltype(auto) ，和 auto 一样，它会从其初始化表达式出发来推导型别，但是它的型别推导使用的是 decltype 的规则

# 掌握查看型别推导结果的方法
* 利用IDE编辑器、编译器错误消息和 Boost.Typelndex 库常常能够查看到推导而得的型别
* 有些工具产生的结果可能会无用或者不准确，所以理解C+＋型别推导规则是必要的

# 优先选用 auto, 而非显式型别声
* auto 变量必须初始化，基本上对会导致兼容性和效率问题的型别不匹配现象免疫，还可以简化重构流程，通常也比显式指定型别要少打一些字。
* auto 型别的变量都有着条款2 和条款6 中所描述的毛病

# auto 推导的型别不符合要求时，使用带显式型别的初始化物习惯用法
* “隐形”的代理型别 可以导致 auto 祁据初始化表达式推导出 “错误的＂型别
* 带显式型别的初始化物习惯用法强制 auto 推导出你想要的型别。

# 在创建对象时注意区分 和｛｝
* 大括号初始化可以应用的语境最为宽泛，可以阻止隐式窄化型别转换，还对最令人苦恼之解析语法免疫
* 在构造函数重载决议期间，只要有任何可能，大括号初始化物就会与带有std::initializer_list型别的形参相匹配，即使其他重载版本有着貌似更加匹配的形参表
* 使用小括号还是大括号，会造成结果大相径庭的一个例子是：使用两个实参来创建一个 std::vector<数值型别＞对象
* 在模板内容进行对象创这时，到底应该使用小括号还是大括号会成为一个棘手问题。

# 条款 ：优先选用 nullptr, 而非 NULL
* 相对于NULL, 优先选用nullptr 
* 避免在整型和指针型别之间重载

# 优先选用别名声明，而非 typedef
* typedef 不支持模板化，但别名声明支持
* 别名模板可以让人免写“::type" 后缀,并且在模板内,对于内嵌 typedef的引用经常要求加上 typename 前缀

# 优先选用限定作用域的枚举型别，而非不限作用域的枚举型别 
* C++98 风格的枚举型别，现在称为不限范围的枚举型别
* 限定作用域的枚举型别仅在枚举型别内可见。它们只能通过强制型别转换以转换至其他型别。
* 限定作用域的枚举型别和不限范围的枚举型别都支持底层型别指定。限定作用成的枚举型别的默认底层型别是 int, 而不限范围的枚举型别没有默认底层型别
* 限定作用域的枚举型别总是可以进行前置声明，而不限范围的枚举型别却只有在指定了默认底层型别的前提下才能进行前置声明

# 优先选用删除函数，而非 private 未定义函数
* 优先选用删除函数，而非 private 未定义函数
* 任何函数都可以被删除，包括非成员函数和模板具现

# 为意在改写的函数添加 override 声明
* 为意在改写的函数添加 override 声明
* 成员函数引用饰词使得对于左值和右值对象(*this)的处理能够区分开来。

# 优先选用 const_iterator, 而非 iterator
* 优先选用 const_iterator, 而非 iterator
* 在最通用的代码中，优先选用非成员函数版本的begin end和rbegin等，而非其成员函数版本

# 只要函数不会发射异常，就为其加上noexcept 声明
* noexcept 声明是函数接口的组成部分，这意味着调用方可能会对它有依赖
* 相对于不带 noexcept 声明的函数，带有 noexcept 声明的函数有更多机会得到优化
* noexcept 性质对于移动操作、 swap 、函数释放函数和析构函数最有价值
* 大多数函数都是异常中立的，不具备 noexcept 性质

# 只要有可能使用 constexpr, 就使用它
* constexpr 对象都具各 const 属性，并由编译期已知的值完成初始化.
* constexpr 函数在调用时若传入的实参值是编译期已知的，则会产出编译期结果。
* 比起非 constexpr 对象或 constexpr 函数而言, constexpr 对象或 constexpr 函数可以用一个作用域更广的语境中.

# 保证 const 成员函数的线程安全性
* 保证 const 成员函数的线程安全性，除非可以确信它们不会用在并发语境中
* 运用 std::atomic型别的变量会比运用互斥量提供更好的性能,但前者仅适用于单个变量或内存区域的操作

# 理解特种成员函数的生成机制
* 特种成员函数是指那些 c++会自行生成的成员函数: 默认构造函数、析构函数、复制操作，以及移动操作
* 移动操作仅当类中未包含用户显式声明的复制操作、移动操作和析构函数时才生成
* 复制构造函数仅当类中不包含用户显式声明的复制构造函数时才生成，如果该类声明了移动操作则复制构造函数将被删除.复制赋值运算符仅当类中不包含用户显式声明的复制赋值运算符才生成，如果该类声明了移动操作则复制赋值运算符将被删除.在已经存在显式声明的析构函数的条件下，生成复制操作已经成为了被废弃的行为
* 成员函数模板在任何情况下都不会抑制特种成员函数的生成

# 使用 std::unique_ptr 管理具备专属所有权的资源
* std::unique_ptr 是小巧、高速的、具各只移型别的智能指针，对托管资源实施专属所有权语义
* 默认地，资源析构采用 delete 运算符来实现，但可以指定自定义删除器有状态的删除器和采用函数指针实现的删除器会增加 std::unique_ptr别的对象尺寸
* std::unique_ptr转换成std::shared_ptr是容易实现的

# 使用 std::shared_ptr 管理具备共享所有权的资源
* std::shared _ptr 提供方便的手段，实现了任意资源在共享所有权语义下进行生命周期管理的垃圾回收
* std::unique _ptr 相比， std::shared_ptr 的尺寸通常是裸指针尺寸的两倍，它还会带来控制块的开销，并要求原子化的引用计数操作
* 默认的资源析构通过 delete 运算符进行，但同时也支持定制删除器。删除器的型别对 std::shared_ptr 的型别没有影响
* 避免使用裸指针型别的变量来创建 std::shared _ptr 指针

# 对千类似 std::shared_ptr, 但有可能空悬的指针使用 std::weak_ptr
* 使用 std::weak_ptr 来代替可能空悬的 std::shared_ptr
* std::weak_ptr 可能的用武之地包括缓存，观察者列表， 以及进免std::shared_ptr 指针环路

# 优先选用 std::make_unique,std::make_shared, 而非直接使用 new
* 相比于直接使用 new 表达式， make 系列函数消除了重复代码、改进了异常安全性，并且对于std::make_shared和std::allcoated_ shared 而言，生成的目标代码会尺寸史小、速度更快
* 不适于使用 make 系列函数的场景包括需要定制删除器，以及期望直接传递大括号初始化物
* 对于 std::shared_ptr，不建议使用 make 系列函数的额外场景包括:
    * 自定内存管理的类
    * 内存紧张的系统,非常打的对象,以及存在比指涉到相同的对象的std::shared_ptr生存期更久的std::weak_ptr

# 使用 Pimpl 习惯用法时，将特殊成员函数的定义放到实现文件中
* Pimpl惯用法通过降低类的客户和类实现者之间的依赖性,减少了构建遍数.
* 对于采用std::unique_ptr来实现的pImpl指针,须在类的头文件中声明特种成员函数,但在实现文件中定义它们.即使默认函数实现有着正确的行为,也必须这样做
* 上述建议仅适用于std::unique_ptr,但不适用于std::shared_ptr

# 理解 std::move std::forward
* std::move 实施的是无条件的向右值型别的强制型别转换 就其本身而言，它不会执行移动操作
* 仅当传入的实参被绑定到右值时， std::forward 才针对该实参实施向右值型别的强制型别转换
* 在运行期， std::move和std::forward 都不会做任何操作

# 区分万能引用和右值引用
* 如果函数模板形参具各T&&型别，并且T的型别系推导而来，或如果使用auto&&声明其型别，则该形参或对象就是个万能引用
* 如果型别声明并不精确地具备 type&& 的形式，或者型别推导并未发生，则type&& 就代表右值引用
* 若采用右值来初始化万能引用，就会得到一个右值引用. 若采用左值来初始化万能引用，就会得到一个左值引用

# 针对右值引用实施 std::move, 针对万能引用实施 std::forward
* 针对右值引用的最后一次使用实施 std::move, 针对万能引用的最后一次使用实施 std::forward
* 作为按值返回的函数的右值引用和万能引用，依上一条所述采取相同行为
* 若局部对象可能适用于返回值优化 则请勿针对其实施 std: :move和std::forward

# 避免依万能引用型别进行重载
* 把万能引用作为重载候选型别，几乎总会让该重载版本在始料未及的情况下被调用到.
* 完美转发构造函数的问题尤其严重，因为对于非常量的左值而言,他们一般都会形成相对于复制构造函数的更加匹配,并且它们还会劫持派生类中对基类的复制和移动构造函数的调用

# 熟悉依万能引用型别进行重载的替代方案
* 如果不使用万能引用和重载的组合，则替代方案包括使用彼此不同的函数名字、传递 const T& 型别的形参、传值和标签分派
* 经由 std::enable_if 对模板施加限制，就可以将万能引用和重载一起使用，不过这种技术控制了编译器可以调用到接受万能引用的重载版本的条件。
* 万能引用形参通常在性能方面具各优势，但在易用性方面一般会有劣势

# 理解引用折叠
* 引用折叠会在四种语境中发生：模板实例化、 auto 型别生成、创建和运用 typedef 和别名卢明，以及 decltype
* 当编译器在引用折叠的语境下生成引用的引用时，结果会变成单个引用.如果原始的引用中有任一引用为左值引用，则结果为左值引用.否则，结果为右值引用.
* 万能引用就是在型别推导的过程会区别左值和右值，以及会发生引用折叠的语境中的右值引用

# 假定移动操作不存在 成本高、未使用
* 假定移动操作不存在、成本高、未使用
* 对于那些型别或对于移动语义的支持情况已知的代码,则无需做以上假定

# 熟悉完美转发的失败情形
* 完美转发的失败情形,是源于模板型别推导失败,或推导结果是错误的型别
* 会导致完美转发失败的实参种类有大括号初始化物、以值0或NULL表达的空指针、仅有声明的整型static const成员变量、模板或重载的函数名字,以及位域.

# 优先选用基千任务而非基千线程的程序设计
* std::thread的API未提供直接获取异步运行函数返回值的途径，而且如果那些函数抛出异常，程序就会终止
* 基于线程的程序设计要求手动管理线程耗尽、超订、负载均衡，以及新平台适配
* 经由应用了默认启动策略的std::async进行基于任务的程序设计,大部分这类问题都能找到解决之道

# 如果异步是必要的，则指定std::launch::async
* std::async 的默认启动策略既允许任务以异步方式执行，也允许任务以同步方式执行
* 如此的弹性会导致使用 thread_local 变量时的不确定性，隐含着任务可能永远不会执行，还会影响运用了基于超时的 wait 调用的程序逻辑
* 如果异步是必要的，则指定 std::launch::async

# std::thread 型别对象在所有路径皆不可联结
* std::thread 型别对象在所有路径皆不可联结
* 在析构时调用 join 可能导致难以调试的性能异常
* 在析构时调用 detach 可能导致难以调试的未定义行为
* 在成员列表的最后声明 std::thread 型别对象

# 对变化多端的线程句柄析构函数行为保持关注
* 期值的析构函数在常规情况下，仅会析构期值的成员变量。
* 指涉到经由 std::aysnc 启动的未推迟任务的共享状态的最后一个期值会保持阻塞,直至该任务结束

# 考虑针对一次性事件通信使用以 void 为模板型别实参的期值
* 如果仅为了实现平凡事件通信，基于条件变量的设计会要求多余的互斥量，这会给相互关联的检测和反应任务带来约束，并要求反应任务校验事件确已发生
* 使用标志位的设计可以避免上述问题，但这一设计基于轮询而非阻塞
* 条件变量和标志位可以一起使用 但这样的通信机制设计结果不甚自然
* 使用 std::promise 型别对象和期值就可以回避这些问题，但是一来这个途径为了共享状态需要使用堆内存，而且仅限于一次性通信

# 对并发使用 std::atomic, 对特种内存使用 volatile
* std::atomic 用于多线程访问的数据,且不用互斥量,它是摸写并发软件的工具。
* volatile 用于读写操作不可以被优化掉的内存,它是在面对特种内存时使用的工具