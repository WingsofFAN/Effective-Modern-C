#include <iostream>
#include <atomic>


/*对并发使用 std::atomic, 对特种内存使用 volatile

volatile关键字主要用于保证变量的可见性和禁止指令重排序。

volatile关键字的作用:
1.保证变量的可见性：在多线程环境中，volatile关键字可以确保一个线程对变量的修改能够立即被其他线程看到，从而保证了数据的实时性和一致性。
2.禁止指令重排序：编译器和处理器可能会为了优化性能而对指令进行重排序。使用volatile关键字可以防止这种重排序，确保程序按照预期的顺序执行。

volatile关键字的限制:
尽管volatile关键字提供了可见性和禁止指令重排序的保证，但它也有一些局限性：
1.不保证原子性：volatile关键字不能保证对数据操作的原子性，也就是说，它不能保证在多线程环境下对变量的操作是不可分割的3。
2.不保证顺序性：volatile关键字也不能保证操作的顺序性，因此它不适合用于需要严格顺序执行的场景4。

volatile关键字的底层实现原理
volatile关键字的底层实现原理是通过内存屏障来实现的。内存屏障是一种CPU指令，它可以阻止指令重排序，确保特定操作的执行顺序。

*/


int main()
{

    std::atomic<int> ai(0);
    ai = 10;
    std::cout << ai ;
    int  b = 10;   //此句在实际的运行过程中,可能会被上调至前或后,来优化计算效率
    ++ ai;
    -- ai;
    //通过加锁,保证整个过程是互斥的

    /*
    std::atomic 型别对象的运用会对代码可以如何重新排序施加限制，并且这样
    的限制之一就是，在源代码中，不得将任何代码提前至后续会出现std::atomic
    变量的写入操作的位置（或使其他内核视作这样的操作会发生）。
    */


    volatile int a = 0;
    a = 10;
    a = 20;
    ++a;
    volatile int b1 = a;
    /*
    加上了volatile关键字,保证变量的可见性，禁止指令重排序,
    即在编译中,不会对volatile修饰的变量去进行优化和重排序,
    而是严格根据源代码中的顺序进行编译和操作.
    */


    return 0;
}